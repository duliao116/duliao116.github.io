# 运算符重载

## 加法重载

```python
class Var:
    def __init__(self, name, value, t):
        self.name = name
        self.value = value
        self.t = t

    def __add__(self, other):
        if other.t != self.t:
            raise ValueError("类型不一致")
        return Var(self.name, self.value + other.value, self.t)

    def __str__(self):
        return f'{self.name}, {self.value}, {self.t}'


def test(a, b):
    """
    :param a: 变量1
    :param b: 变量2
    :return: 结果
    >>> a = Var('age', 23, 'int')
    >>> b = Var('age', 32, 'int')
    >>> isinstance(a+b, Var)
    True
    >>> print(a+b)
    age, 55, int
    """


if __name__ == '__main__':
    import doctest
    doctest.testmod()

```

## 其它运算重载

| 运算符         | 表达      | 在内部                   |
| :------------- | :-------- | :----------------------- |
| 相加（+）      | p1 + p2   | p1 .__ add __（p2）      |
| 相减（-）      | p1-p2     | p1 .__ sub __（p2）      |
| 相乘（*）      | p1 * p2   | p1 .__ mul __（p2）      |
| 求幂（**）     | p1 ** p2  | p1 .__ pow __（p2）      |
| 相除（/）      | p1 / p2   | p1 .__ truediv __（p2）  |
| 整除（//）     | p1 // p2  | p1 .__ floordiv __（p2） |
| 求模 （%）     | p1％p2    | p1 .__ mod __（p2）      |
| 按位左移（<<） | p1 << p2  | p1 .__ lshift __（p2）   |
| 按位右移（>>） | p1 >> p2  | p1 .__ rshift __（p2）   |
| 按位与（and）  | p1 and p2 | p1 .__ and __（p2）      |
| 按位或（or）   | p1 \| 2   | p1 .__ or __（p2）       |
| 按位异或（^）  | p1 ^ p2   | p1 .__ xor __（p2）      |
| 按位否（~）    | 〜p1      | p1 .__ invert __()       |

## 比较符重载

| 操作符         | 表达式   | 内部               |
| :------------- | :------- | :----------------- |
| 小于（<）      | p1 <p2   | p1 .__ lt __（p2） |
| 小于等于（<=） | p1 <= p2 | p1 .__ le __（p2） |
| 等于（==）     | p1 == p2 | p1 .__ eq __（p2） |
| 不等于（!=）   | p1！= p2 | p1 .__ ne __（p2） |
| 大于（>）      | p1> p2   | p1 .__ gt __（p2） |
| 大于等于（>=） | p1> = p2 | p1 .__ ge __（p2） |

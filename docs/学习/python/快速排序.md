---
title: 快速排序
tags:
  - python
  - 算法
---
## 代码
```python
"""
快速排序
"""


def sort1(arr, start, end, partition):
    """
    单边排序算法
    :param partition: 分治算法
    :param arr: 待排序数组
    :param start: 数组的起始下标
    :param end: 数组的结束下标
    """
    if start < end:
        pivot_index = partition(arr, start, end)
        sort1(arr, 0, pivot_index - 1, partition)
        sort1(arr, pivot_index + 1, end, partition)


def partition1(arr, start, end):
    """
    单边循环法：将基准元素移动到合适位置-左边数据都小于它，右边元素都大于它
    :param arr: 待排序数组
    :param start: 起始下标
    :param end: 结束下标
    :return: 基准元素下标
    """
    # 初始指定基准元素
    pivot = arr[start]
    # 小于基准元素值的边界下标
    mark = start
    # range(1,2)为[1]，所以把end+1，意味从指定数组的的第二个元素到最后一个元素，第一个元素是基准元素
    for i in range(start + 1, end + 1):
        # 和基准元素比较，如果小于基准元素，扩展小于基础元素的边界，
        # 即mark向右移动(mark左边的元素都小于基础元素)，然后交换arr[mark](大)和arr[i](小)
        if arr[i] < pivot:
            mark += 1
            tmp = arr[mark]
            arr[mark] = arr[i]
            arr[i] = tmp
    # 将mark位置的元素放到初始位置
    arr[start] = arr[mark]
    # 将基准元素交换mark的位置，这样mark左侧都小于arr[mark]，右侧都是大于等于arr[mark]
    arr[mark] = pivot
    return mark


def partition2(arr, start, end):
    """
    双边循环法：将基准元素移动到合适位置-左边数据都小于它，右边元素都大于它
    :param arr: 待排序数组
    :param start: 开始下标
    :param end: 结束下标
    :return: 基准元素下标
    """
    # 左边指针
    left = start
    # 右边指针
    right = end
    # 初始指定基准元素
    pivot = arr[start]

    while left != right:
        # 右边的值大于基准元素，则左移一位，遇到小于等于基准元素时则停止
        while arr[right] > pivot and left < right:
            right -= 1
        # 左边的值小于等于基准元素，则右移一位，遇到大于基准元素的值则停止
        while arr[left] <= pivot and left < right:
            left += 1

        # 交换左右两个指针的值，此时arr[right]<=pivot，arr[left]>pivot，将小的交换到左边，大的交换到右边
        if left != right:
            tmp = arr[left]
            arr[left] = arr[right]
            arr[right] = tmp

    # 交换初始指定的基准元素（第一个元素）和重新计算出来的基准元素
    arr[start] = arr[left]
    arr[left] = pivot
    return left


if __name__ == '__main__':
    numbers = [4, 7, 3, 5, 6, 2, 8, 1]
    sort1(numbers, 0, len(numbers) - 1, partition2)
    print(numbers)
    numbers = [4, 7, 3, 5, 6, 2, 8, 1]
    sort1(numbers, 0, len(numbers) - 1, partition1)
    print(numbers)

```
::: tip
快速排序主要就是提现了分治的特点，每次找到的其实是基准元素的位置，基准元素左侧的值都小于基准元素，基准元素右侧的值都大于等于基准元素，直到每个元素都作为基准元素找到了自己的位置，排序就结束了。
:::
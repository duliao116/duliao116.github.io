---
title: 冒泡排序
tags:
  - python
  - 算法
---

## 基本冒泡
```python
def sort_1(numbers):
    """
    冒泡排序基本实现
    :param numbers: 待排序列表
    """
    length = len(numbers)
    for i in range(1, length):
        for j in range(length - i):
            if numbers[j] > numbers[j + 1]:
                tmp = numbers[j]
                numbers[j] = numbers[j + 1]
                numbers[j + 1] = tmp
```
::: tip
外层遍历n-1次，故而从1开始；内层便利次数越来越少。
:::

## 优化
```python
def sort_2(numbers):
    """
    冒泡排序，优化已经有序后的循环
    :param numbers: 待排序列表
    """
    length = len(numbers)
    for i in range(1, length):
        is_sorted = True
        for j in range(length - i):
            if numbers[j] > numbers[j + 1]:
                tmp = numbers[j]
                numbers[j] = numbers[j + 1]
                numbers[j + 1] = tmp
                is_sorted = False
        if is_sorted:
            break
```
::: tip
一旦某次循环发现已经有序，立刻退出循环，排序完成。
:::

## 再优化
```python
def sort_3(numbers):
    """
    冒泡排序，后方有序数据的遍历次数
    :param numbers: 待排序列表
    """
    length = len(numbers)
    sort_border = length - 1
    for i in range(1, length):
        is_sorted = True
        for j in range(sort_border):
            if numbers[j] > numbers[j + 1]:
                tmp = numbers[j]
                numbers[j] = numbers[j + 1]
                numbers[j + 1] = tmp
                is_sorted = False
                sort_border = j
        if is_sorted:
            break
```
::: tip
找到未排序的最大值，该值后面的值都是有序的，不必再排。
:::

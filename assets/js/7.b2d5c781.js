(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{371:function(t,e,n){"use strict";n.r(e);var a=n(45),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("最近，遇到一个计算生态补偿金额的业务，具体的计算公式是一个比较麻烦的东西，里面各种数据符号，什么Σ、Φ、α、β之类的玩意，对于我来说，好久不见这些东西，符号该怎么读都差不多忘记了，很是苦恼。最后终于跟客户弄清楚了，公式的意义，就开始编码计算。")]),t._v(" "),n("p",[t._v("公式的数据来源是数据库中查出来的，但数据库中的数据并非就是完整的、干净的，就是说我再处理α*β这类玩意的时候很有可能从数据库中查出来的是一个非数字字符串，或者null数据。那么问题来了，这样子去计算公式程序必然会报各种异常，然后跟客户反应后客户提出要求：运行公式前，先检查公式需要数据的完整性，如果公式需要的数据不符合要求，就在页面上给客户提示，哪些数据有问题。")]),t._v(" "),n("h2",{attrs:{id:"条件判断方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#条件判断方式"}},[t._v("#")]),t._v(" 条件判断方式")]),t._v(" "),n("p",[t._v("将数据从数据库中查出，依次按照各个数据的校验条件进行校验，使用返回字符串的形式返回校验结果。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\tpublic String validate(){\n\tString errorInfo="";\n\t//dataA from database\n\tif(dataA == null){//或者其他条件要求，例如dataA必须为数字，数字范围在[1,20]等\n\t\terrorInfo = "dataA 数据有误";\n\t\treturn;\n\t}\n\t//dataB from database\n\tif(dataB == null){//或者其他条件要求，例如dataA必须为数字，数字范围在[1,20]等\n\t\terrorInfo = "dataB 数据有误";\n\t\treturn;\n\t}\n\t...\n\t//校验完毕，开始执行公式计算\n\t}\n')])])]),n("p",[t._v("这种方式就会有大量的检查代码，重复的逻辑判断"),n("em",[t._v("a==null")]),t._v(","),n("em",[t._v("a is number")]),t._v("等，使代码看起来冗长切不易理解，校验代码和执行代码实际上就可以是两个不同的模块。")]),t._v(" "),n("h2",{attrs:{id:"ibatis方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ibatis方式"}},[t._v("#")]),t._v(" ibatis方式")]),t._v(" "),n("p",[t._v("最近在看ibatis源代码时看到它在处理异常信息时使用了一种非常有趣的方式。首先，有一个保存错误信息的类ErrorContext:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\n\tpublic class ErrorContext {\n\n \t private String resource;\n \t private String activity;\n \t private String objectId;\n \t private String moreInfo;\n \t private Throwable cause;\n\t //setter\n\t //getter\n \t public String toString() {\n   \t StringBuffer message = new StringBuffer();\n\t    // resource\n\t    if (resource != null) {\n\t      message.append("  \\n--- The error occurred in ");\n\t      message.append(resource);\n\t      message.append(".");\n\t    }\t\n\t    // activity\n\t    if (activity != null) {\n\t      message.append("  \\n--- The error occurred while ");\n\t      message.append(activity);\n\t      message.append(".");\n\t    }\n\t    // object\n\t    if (objectId != null) {\n\t      message.append("  \\n--- Check the ");\n\t      message.append(objectId);\n\t      message.append(".");\n\t    }\n\t    // more info\n\t    if (moreInfo != null) {\n\t      message.append("  \\n--- ");\n\t      message.append(moreInfo);\n\t    }\n\t    // cause\n\t    if (cause != null) {\n\t      message.append("  \\n--- Cause: ");\n\t      message.append(cause.toString());\n\t    }\n\t    return message.toString();\n\t  }\n\t  public void reset() {\n\t    resource = null;\n\t    activity = null;\n\t    objectId = null;\n\t    moreInfo = null;\n\t    cause = null;\n\t  }\t\n\t}\n')])])]),n("p",[t._v("然后在程序中使用时，直接在执行每一步关键代码的前面set校验信息，如果程序的下一步出现异常，那就跳到catch块中，将具体的异常信息保存到ErrorContext对象中，最终在处理异常时，就可以将详细的异常信息展示出来：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\tprotected void executeQueryWithCallback(StatementScope statementScope, Connection conn, Object parameterObject, Object resultObject, RowHandler rowHandler, int skipResults, int maxResults)\n      throws SQLException {\n\t//开始设置异常信息\n    ErrorContext errorContext = statementScope.getErrorContext();\n    errorContext.setActivity("preparing the mapped statement for execution");\n    errorContext.setObjectId(this.getId());\n    errorContext.setResource(this.getResource());\n\n    try {\n      parameterObject = validateParameter(parameterObject);\n\n      Sql sql = getSql();\n\t  //执行代码前设置异常信息\n      errorContext.setMoreInfo("Check the parameter map.");\n      ParameterMap parameterMap = sql.getParameterMap(statementScope, parameterObject);\n\n      errorContext.setMoreInfo("Check the result map.");\n      ResultMap resultMap = sql.getResultMap(statementScope, parameterObject);\n\n      statementScope.setResultMap(resultMap);\n      statementScope.setParameterMap(parameterMap);\n\n      errorContext.setMoreInfo("Check the parameter map.");\n      Object[] parameters = parameterMap.getParameterObjectValues(statementScope, parameterObject);\n\n      errorContext.setMoreInfo("Check the SQL statement.");\n      String sqlString = sql.getSql(statementScope, parameterObject);\n\n      errorContext.setActivity("executing mapped statement");\n      errorContext.setMoreInfo("Check the SQL statement or the result map.");\n      RowHandlerCallback callback = new RowHandlerCallback(resultMap, resultObject, rowHandler);\n      sqlExecuteQuery(statementScope, conn, sqlString, parameters, skipResults, maxResults, callback);\n\n      errorContext.setMoreInfo("Check the output parameters.");\n      if (parameterObject != null) {\n        postProcessParameterObject(statementScope, parameterObject, parameters);\n      }\n\n      errorContext.reset();\n      sql.cleanup(statementScope);\n      notifyListeners();\n    } catch (SQLException e) {\n\t  //异常信息保存近errorContext对象中\n      errorContext.setCause(e);\n      throw new NestedSQLException(errorContext.toString(), e.getSQLState(), e.getErrorCode(), e);\n    } catch (Exception e) {\n      errorContext.setCause(e);\n      throw new NestedSQLException(errorContext.toString(), e);\n    }\n\t}\n\n')])])]),n("p",[n("em",[t._v("这种方式的好处就是不必挨个的去使用if语句判断，只需要在合适的地方加上错误信息的保存，程序的正常执行逻辑不变，当正常执行逻辑出现异常时，自然就会中断，然后此时保存的异常信息就是最近的信息。\n当然，这种方式处理较为复杂的条件判断是就会比较麻烦，比如:a的数字范围是[10,20]，如果a的数值为30，带入到公式中，公式也是可以计算的，不会出现异常。")])]),t._v(" "),n("h2",{attrs:{id:"spring方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring方式"}},[t._v("#")]),t._v(" spring方式")]),t._v(" "),n("p",[t._v("使用过Spring的同学想必就见过这样的代码:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\tpublic void addCallback(ListenableFutureCallback<? super T> callback) {\n\t\tAssert.notNull(callback, \"'callback' must not be null\");\n\t\tsynchronized (mutex) {\n\t\t\tswitch (state) {\n\t\t\t\tcase NEW:\n\t\t\t\t\tcallbacks.add(callback);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SUCCESS:\n\t\t\t\t\tcallback.onSuccess((T)result);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FAILURE:\n\t\t\t\t\tcallback.onFailure((Throwable) result);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n")])])]),n("p",[t._v("Spring中的很多操作的一开始都有这么一个断言Assert.notNull()，那么这个notNull()方法是什么呢？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\tpublic static void notNull(Object object, String message) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\tpublic static void notNull(Object object) {\n\t\tnotNull(object, "[Assertion failed] - this argument is required; it must not be null");\n\t}\n')])])]),n("p",[t._v("可以看出，如果断言失败，那么程序就会抛出异常，这是非常严格的校验方式了。看到这里，有人也行会问，这根我们的校验有什么关系，我们是要返回具体的校验信息的。到这里，我们其实可以看出，假如我们想要返回具体的校验信息，只需要综合ibatis和spring的异常处理方式，在Assert之前把错误信息set近Context中就行了:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\tpublic String validate(){\n\ttry{\n\t\t//dataA from database\n\t\terrorContext.setErrorInfo("数据A不能为空");\n\t\tAssert.notNull(dataA);\n\t\terrorContext.setErrorInfo("数据范围为[10,20]");\n\t\tAssert.range(10,20);\n\t}catch(Exception e){\n\t\t//返回异常信息\n\t\treturn errorContext.toString();\n\t}\n\t...\n\t//校验完毕，开始执行公式计算\n\t}\n')])])]),n("p",[t._v("这样，既避免的代码重复，逻辑混乱，也可以更好的返回详细信息。")])])}),[],!1,null,null,null);e.default=r.exports}}]);